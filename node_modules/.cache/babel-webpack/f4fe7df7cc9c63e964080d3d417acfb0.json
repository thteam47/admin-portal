{"ast":null,"code":"/**\r\n * Animation module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\nimport { options } from \"../Options\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\nexport function animate(duration, callback) {\n  var disposed = false;\n  // TODO use performance.now() ?\n  var startTime = Date.now();\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\nfunction getProgressColor(progress, from, to) {\n  var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\n  if (from.alpha != to.alpha) {\n    color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\n  }\n  return color;\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\nvar AnimationDisposer = /** @class */function () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n  return AnimationDisposer;\n}();\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\nvar Animation = /** @class */function (_super) {\n  __extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n  function Animation(object, animationOptions, duration, easing) {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\";\n    // Override duration if animations disabled system-wide\n    if (options.animationsEnabled === false) {\n      duration = 0;\n    }\n    // Set parameters\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n    if (easing) {\n      _this.easing = easing;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  // TODO verify that this is correct\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n  Animation.prototype.delay = function (delay) {\n    var _this = this;\n    //@todo Maybe not use `bind()`\n    if (delay > 0) {\n      this.pause();\n      // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n    return this;\n  };\n  Animation.prototype._start = function () {\n    this._isFinished = false;\n    // Clear delay timeout if there was one\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    this.stopSameAnimations();\n    // Reset counters\n    this._pause = false;\n    // Register animation\n    $array.move(system.animations, this);\n    // Register this animation in object's `animations` list\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.start = function () {\n    this._start();\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = [];\n    // Process initial property values\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options_1 = this.animationOptions[i];\n      if (!$type.hasValue(options_1.from)) {\n        if (options_1.childObject) {\n          options_1.from = options_1.childObject[options_1.property];\n        } else {\n          options_1.from = this.object[options_1.property];\n          if (!$type.hasValue(options_1.from)) {\n            options_1.from = SVGDefaults[options_1.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n      }\n\n      if (options_1.from == options_1.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options_1);\n      } else if (!$type.hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options_1);\n        $array.remove(this.animationOptions, options_1);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options_1.to)) {\n          // Numeric value\n          options_1.updateMethod = getProgressNumber;\n          // Check if initial value is not Percent\n          if (options_1.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\n            if (!isNaN(convertedFrom)) {\n              options_1.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (isNaN(options_1.from)) {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options_1.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options_1.from) {\n              options_1.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (options_1.to instanceof Percent) {\n            // Percent\n            options_1.updateMethod = getProgressPercent;\n            // Check if the initial value is maybe in pixels\n            if (!isNaN(options_1.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\n              if (!isNaN(convertedFrom)) {\n                options_1.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        }\n      }\n    }\n    // Apply static options (just in case they were reset by previous\n    // animation loop)\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n    this.update();\n    // If duration is 0, just end animation\n    if (this.duration === 0) {\n      this.end();\n    }\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.pause = function () {\n    this._pause = true;\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.resume = function () {\n    this._start();\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n    this.setProgress(1);\n    // Apply static options\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    }\n    // Check if we should loop\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n    return this;\n  };\n  /**\r\n   * Stops animation immediately leaving properties in their current values.\r\n   */\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n    this._time = this.duration * progress; // just in case we call this from outside\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n      this.setProgress(progress);\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n    return this;\n  };\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this;\n    // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n  Animation.prototype.asFunction = function (field) {\n    return field == \"easing\" || _super.prototype.asIs.call(this, field);\n  };\n  return Animation;\n}(BaseObjectEvents);\nexport { Animation };","map":{"version":3,"names":["__extends","BaseObjectEvents","SVGDefaults","Disposer","Color","Percent","percent","$async","$ease","$colors","$math","$array","$type","system","options","animate","duration","callback","disposed","startTime","Date","now","loop","diff","nextFrame","getProgressNumber","progress","from","to","getProgressPercent","getProgressColor","color","interpolate","rgb","alpha","getHybridProperty","property","type","charAt","toUpperCase","substr","AnimationDisposer","array","_disposer","length","dispose","prototype","isDisposed","Animation","_super","object","animationOptions","easing","_this","call","linear","_loop","_pause","_delayTimeout","_time","_isFinished","className","animationsEnabled","toArray","applyTheme","debug","pause","delay","move","animations","id_1","setTimeout","start","clearTimeout","_start","removeDispose","stopSameAnimations","requestFrame","_startTime","staticOptions","i","options_1","hasValue","childObject","remove","push","isNumber","updateMethod","convertedFrom","isNaN","applyStaticOptions","events","isEnabled","event_1","target","dispatchImmediately","update","end","count","Infinity","resume","setProgress","event_2","stop","kill","isFinished","each","skipEvent","event_3","value","event_4","fitToRange","timeProgress","round","Object","defineProperty","get","enumerable","configurable","copy","animation","delayed","killed_1","newOptions","oldOptions","asFunction","field","asIs"],"sources":["/home/unutu/go/src/github.com/thteam47/admin-portal/node_modules/@amcharts/amcharts4/.internal/core/utils/Animation.js"],"sourcesContent":["/**\r\n * Animation module.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents } from \"../Base\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer } from \"../utils/Disposer\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\nimport { options } from \"../Options\";\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\r\nexport function animate(duration, callback) {\r\n    var disposed = false;\r\n    // TODO use performance.now() ?\r\n    var startTime = Date.now();\r\n    function loop(now) {\r\n        if (!disposed) {\r\n            var diff = now - startTime;\r\n            if (diff >= duration) {\r\n                callback(1);\r\n            }\r\n            else {\r\n                $async.nextFrame(loop);\r\n                callback(diff / duration);\r\n            }\r\n        }\r\n    }\r\n    $async.nextFrame(loop);\r\n    return new Disposer(function () {\r\n        disposed = true;\r\n    });\r\n}\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressNumber(progress, from, to) {\r\n    return from + ((to - from) * progress);\r\n}\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressPercent(progress, from, to) {\r\n    return new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\r\nfunction getProgressColor(progress, from, to) {\r\n    var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n    if (from.alpha != to.alpha) {\r\n        color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\r\n    }\r\n    return color;\r\n}\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\r\nfunction getHybridProperty(property, type) {\r\n    return type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\nvar AnimationDisposer = /** @class */ (function () {\r\n    function AnimationDisposer(array) {\r\n        this._disposer = new Disposer(function () {\r\n            while (array.length !== 0) {\r\n                array[0].dispose();\r\n            }\r\n        });\r\n    }\r\n    AnimationDisposer.prototype.isDisposed = function () {\r\n        return this._disposer.isDisposed();\r\n    };\r\n    AnimationDisposer.prototype.dispose = function () {\r\n        this._disposer.dispose();\r\n    };\r\n    return AnimationDisposer;\r\n}());\r\nexport { AnimationDisposer };\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nvar Animation = /** @class */ (function (_super) {\r\n    __extends(Animation, _super);\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param object            An object animation should run on\r\n     * @param animationOptions  One or several (array) of animation options\r\n     * @param duration          Duration (ms)\r\n     * @param easing            Easing function\r\n     */\r\n    function Animation(object, animationOptions, duration, easing) {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * Duration of the animation in milliseconds.\r\n         */\r\n        _this.duration = 0;\r\n        /**\r\n         * Easing function to use.\r\n         *\r\n         * @see {@link Ease}\r\n         */\r\n        _this.easing = $ease.linear;\r\n        /**\r\n         * Contains progress of the current animation: 0 (start) to 1 (end).\r\n         */\r\n        _this.progress = 0;\r\n        /**\r\n         * Indicated how many times animation should loop.\r\n         */\r\n        _this._loop = 0;\r\n        /**\r\n         * Animation is paused.\r\n         */\r\n        _this._pause = false;\r\n        /**\r\n         * Holds reference to timeout for delayed play.\r\n         */\r\n        _this._delayTimeout = null;\r\n        /**\r\n         * Elapsed time in currently playing animation.\r\n         */\r\n        _this._time = 0;\r\n        _this._isFinished = false;\r\n        _this.className = \"Animation\";\r\n        // Override duration if animations disabled system-wide\r\n        if (options.animationsEnabled === false) {\r\n            duration = 0;\r\n        }\r\n        // Set parameters\r\n        _this.object = object;\r\n        _this.animationOptions = $array.toArray(animationOptions);\r\n        _this.duration = duration;\r\n        if (easing) {\r\n            _this.easing = easing;\r\n        }\r\n        // Run check if there are already animations playing on the same properties\r\n        // and stop them - the last animation takes precedence\r\n        //this.stopSameAnimations();\r\n        /*if ($type.hasValue(callback)) {\r\n            // TODO don't use .call\r\n            this.events.on(\"animationended\", callback, object);\r\n        }*/\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    // TODO verify that this is correct\r\n    Animation.prototype.debug = function () { };\r\n    /**\r\n     * Disposes this object, clears up after itself.\r\n     */\r\n    Animation.prototype.dispose = function () {\r\n        _super.prototype.dispose.call(this);\r\n        this.pause();\r\n    };\r\n    /**\r\n     * Delays animation start by X milliseconds.\r\n     *\r\n     * @param delay  Delay (ms)\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.delay = function (delay) {\r\n        var _this = this;\r\n        //@todo Maybe not use `bind()`\r\n        if (delay > 0) {\r\n            this.pause();\r\n            // This is so that it will get disposed if `this.object` is disposed\r\n            // TODO hacky, figure out a better way\r\n            $array.move(this.object.animations, this);\r\n            var id_1 = setTimeout(function () {\r\n                _this._delayTimeout = null;\r\n                _this.start();\r\n            }, delay);\r\n            this._delayTimeout = new Disposer(function () {\r\n                clearTimeout(id_1);\r\n            });\r\n        }\r\n        return this;\r\n    };\r\n    Animation.prototype._start = function () {\r\n        this._isFinished = false;\r\n        // Clear delay timeout if there was one\r\n        if (this._delayTimeout) {\r\n            this.removeDispose(this._delayTimeout);\r\n            this._delayTimeout = null;\r\n        }\r\n        // Run check if there are already animations playing on the same properties\r\n        // and stop them - the last animation takes precedence\r\n        this.stopSameAnimations();\r\n        // Reset counters\r\n        this._pause = false;\r\n        // Register animation\r\n        $array.move(system.animations, this);\r\n        // Register this animation in object's `animations` list\r\n        $array.move(this.object.animations, this);\r\n        system.requestFrame();\r\n    };\r\n    /**\r\n     * Starts animation.\r\n     *\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.start = function () {\r\n        this._start();\r\n        this._startTime = Date.now();\r\n        this._time = 0;\r\n        this.staticOptions = [];\r\n        // Process initial property values\r\n        for (var i = this.animationOptions.length - 1; i >= 0; i--) {\r\n            var options_1 = this.animationOptions[i];\r\n            if (!$type.hasValue(options_1.from)) {\r\n                if (options_1.childObject) {\r\n                    options_1.from = options_1.childObject[options_1.property];\r\n                }\r\n                else {\r\n                    options_1.from = this.object[options_1.property];\r\n                    if (!$type.hasValue(options_1.from)) {\r\n                        options_1.from = SVGDefaults[options_1.property];\r\n                    }\r\n                }\r\n                /*if (!$type.hasValue(options.from)) {\r\n                    throw Error(\"Could not get initial transition value.\");\r\n                }*/\r\n            }\r\n            if (options_1.from == options_1.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n                $array.remove(this.animationOptions, options_1);\r\n            }\r\n            else if (!$type.hasValue(options_1.from) || (!(options_1.from instanceof Percent) && (options_1.to instanceof Percent)) || ((options_1.from instanceof Percent) && !(options_1.to instanceof Percent))) {\r\n                // Initial value is undefined, treat it as static\r\n                this.staticOptions.push(options_1);\r\n                $array.remove(this.animationOptions, options_1);\r\n            }\r\n            else {\r\n                // Use different update methods for different value types\r\n                if ($type.isNumber(options_1.to)) {\r\n                    // Numeric value\r\n                    options_1.updateMethod = getProgressNumber;\r\n                    // Check if initial value is not Percent\r\n                    if (options_1.from instanceof Percent) {\r\n                        // It is. Let's convert it to pixel value\r\n                        // @todo Check if we can do this in a less hacky way\r\n                        var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\r\n                        if (!isNaN(convertedFrom)) {\r\n                            options_1.from = convertedFrom;\r\n                        }\r\n                        else {\r\n                            this.staticOptions.push(options_1);\r\n                            $array.remove(this.animationOptions, options_1);\r\n                        }\r\n                    }\r\n                    else if (isNaN(options_1.from)) {\r\n                        // Static value\r\n                        this.staticOptions.push(options_1);\r\n                        $array.remove(this.animationOptions, options_1);\r\n                    }\r\n                }\r\n                else {\r\n                    // Check if maybe we have a color or percent value\r\n                    if (options_1.to instanceof Color) {\r\n                        // Yup - set resolved named color\r\n                        //options.from = $colors.stringToColor(<string>options.from);\r\n                        if (options_1.from) {\r\n                            options_1.updateMethod = getProgressColor;\r\n                        }\r\n                        else {\r\n                            // Static value\r\n                            this.staticOptions.push(options_1);\r\n                            $array.remove(this.animationOptions, options_1);\r\n                        }\r\n                    }\r\n                    else if (options_1.to instanceof Percent) {\r\n                        // Percent\r\n                        options_1.updateMethod = getProgressPercent;\r\n                        // Check if the initial value is maybe in pixels\r\n                        if (!isNaN(options_1.from)) {\r\n                            // It is. Let's convert it\r\n                            // @todo Check if we can do this in a less hacky way\r\n                            var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\r\n                            if (!isNaN(convertedFrom)) {\r\n                                options_1.from = percent(convertedFrom * 100);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Static value\r\n                        this.staticOptions.push(options_1);\r\n                        $array.remove(this.animationOptions, options_1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Apply static options (just in case they were reset by previous\r\n        // animation loop)\r\n        this.applyStaticOptions();\r\n        if (this.events.isEnabled(\"animationstarted\")) {\r\n            var event_1 = {\r\n                type: \"animationstarted\",\r\n                target: this,\r\n                progress: this.progress\r\n            };\r\n            this.events.dispatchImmediately(\"animationstarted\", event_1);\r\n        }\r\n        this.update();\r\n        // If duration is 0, just end animation\r\n        if (this.duration === 0) {\r\n            this.end();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets loop count for the animation. If parameter is not a valid number the\r\n     * animation will keep on looping indefinitely.\r\n     *\r\n     * @param count  Number of times to loop animation\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.loop = function (count) {\r\n        if (!$type.isNumber(count)) {\r\n            count = Infinity;\r\n        }\r\n        this._loop = count;\r\n        return this;\r\n    };\r\n    /**\r\n     * Pauses animation.\r\n     *\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.pause = function () {\r\n        this._pause = true;\r\n        if (this._delayTimeout) {\r\n            this.removeDispose(this._delayTimeout);\r\n            this._delayTimeout = null;\r\n        }\r\n        $array.remove(system.animations, this);\r\n        $array.remove(this.object.animations, this);\r\n        return this;\r\n    };\r\n    /**\r\n     * Resumes paused animation.\r\n     *\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.resume = function () {\r\n        this._start();\r\n        this._startTime = Date.now() - this._time;\r\n        return this;\r\n    };\r\n    /**\r\n     * Jumps to animation end. If animation is set to loop, this will start\r\n     * another round of animation from start.\r\n     *\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.end = function () {\r\n        // Pause and complete the progress\r\n        if (this._loop == 0) {\r\n            this.pause();\r\n        }\r\n        this.setProgress(1);\r\n        // Apply static options\r\n        this.applyStaticOptions();\r\n        if (this.events.isEnabled(\"animationended\")) {\r\n            var event_2 = {\r\n                type: \"animationended\",\r\n                target: this,\r\n                progress: this.progress\r\n            };\r\n            this.events.dispatchImmediately(\"animationended\", event_2);\r\n        }\r\n        // Check if we should loop\r\n        if (this._loop > 0) {\r\n            this._loop--;\r\n            this.start();\r\n        }\r\n        else {\r\n            this.stop();\r\n            this._isFinished = true;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Stops animation immediately leaving properties in their current values.\r\n     */\r\n    Animation.prototype.kill = function () {\r\n        this.pause();\r\n        this._isFinished = true;\r\n    };\r\n    /**\r\n     * Returns indicator if this animation is finished or not\r\n     *\r\n     * @return Is finished?\r\n     */\r\n    Animation.prototype.isFinished = function () {\r\n        return this._isFinished;\r\n    };\r\n    /**\r\n     * Applies static options that can't be animated.\r\n     */\r\n    Animation.prototype.applyStaticOptions = function () {\r\n        var _this = this;\r\n        $array.each(this.staticOptions, function (options) {\r\n            if (options.childObject) {\r\n                options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\r\n            }\r\n            else {\r\n                _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Stops animation.\r\n     *\r\n     * When animation is stopped, the properties of the target object will remain\r\n     * where they were at the moment when `stop()` was called.\r\n     *\r\n     * @param skipEvent  Do not trigger `animationstopped` event\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.stop = function (skipEvent) {\r\n        this.pause();\r\n        if (!skipEvent) {\r\n            if (this.events.isEnabled(\"animationstopped\")) {\r\n                var event_3 = {\r\n                    type: \"animationstopped\",\r\n                    target: this,\r\n                    progress: this.progress\r\n                };\r\n                this.events.dispatchImmediately(\"animationstopped\", event_3);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets current progress and updates object's numeric and color values.\r\n     *\r\n     * @param progress Progress (0-1)\r\n     */\r\n    Animation.prototype.setProgress = function (progress) {\r\n        var _this = this;\r\n        this._time = this.duration * progress; // just in case we call this from outside\r\n        $array.each(this.animationOptions, function (options) {\r\n            if (options.updateMethod && $type.hasValue(options.from)) {\r\n                var value = options.updateMethod(progress, options.from, options.to);\r\n                if (options.childObject) {\r\n                    options.childObject[options.property] = value;\r\n                }\r\n                else {\r\n                    _this.object[options.property] = value;\r\n                }\r\n            }\r\n        });\r\n        this.progress = progress;\r\n        if (this.events.isEnabled(\"animationprogress\")) {\r\n            var event_4 = {\r\n                type: \"animationprogress\",\r\n                target: this,\r\n                progress: this.progress\r\n            };\r\n            this.events.dispatchImmediately(\"animationprogress\", event_4);\r\n        }\r\n        system.requestFrame();\r\n    };\r\n    /**\r\n     * Tracks and sets progress according to time or frames.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Animation\r\n     */\r\n    Animation.prototype.update = function () {\r\n        if (!this._pause) {\r\n            var progress = void 0;\r\n            this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\r\n            var timeProgress = this._time / this.duration;\r\n            progress = this.easing(timeProgress);\r\n            if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n                progress = 1;\r\n            }\r\n            this.setProgress(progress);\r\n            if ($math.round(this._time / this.duration, 6) == 1) {\r\n                this.end();\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    Object.defineProperty(Animation.prototype, \"delayed\", {\r\n        /**\r\n         * Returns `true` if this animation is delayed.\r\n         *\r\n         * @readonly\r\n         * @return [description]\r\n         */\r\n        get: function () {\r\n            return this._delayTimeout ? true : false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Checks other animations currently running on the same object and removes\r\n     * overlapping options from those other animations that are contained in\r\n     * this animation.\r\n     *\r\n     * This is needed to ensure that no two confurent animations step on each\r\n     * other's toes by trying to animate the same property.\r\n     */\r\n    Animation.prototype.stopSameAnimations = function () {\r\n        var _this = this;\r\n        // stop animation of the same property\r\n        // TODO make this more efficient\r\n        // TODO don't copy the array\r\n        $array.each($array.copy(this.object.animations), function (animation) {\r\n            if (animation !== _this && !animation.delayed) {\r\n                var killed_1 = [];\r\n                $array.each(_this.animationOptions, function (newOptions) {\r\n                    $array.each(animation.animationOptions, function (oldOptions) {\r\n                        if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n                            killed_1.push(oldOptions);\r\n                            if (animation.animationOptions.length == 0) {\r\n                                animation.kill();\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n                $array.each(killed_1, function (oldOptions) {\r\n                    $array.remove(animation.animationOptions, oldOptions);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Adds easing functions to \"function\" fields.\r\n     *\r\n     * @param field  Field name\r\n     * @return Assign as function?\r\n     */\r\n    Animation.prototype.asFunction = function (field) {\r\n        return field == \"easing\" || _super.prototype.asIs.call(this, field);\r\n    };\r\n    return Animation;\r\n}(BaseObjectEvents));\r\nexport { Animation };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}